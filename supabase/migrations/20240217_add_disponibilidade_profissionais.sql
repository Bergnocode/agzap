-- Criar enum para dias da semana
CREATE TYPE dia_semana AS ENUM ('domingo', 'segunda', 'terca', 'quarta', 'quinta', 'sexta', 'sabado');

-- Criar tabela de disponibilidade regular
CREATE TABLE public.disponibilidade_profissional (
    id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    id_profissional bigint NOT NULL,
    dia_semana dia_semana NOT NULL,
    hora_inicio TIME NOT NULL,
    hora_fim TIME NOT NULL,
    ativo boolean DEFAULT true,
    CONSTRAINT disponibilidade_profissional_pkey PRIMARY KEY (id),
    CONSTRAINT disponibilidade_profissional_id_profissional_fkey 
        FOREIGN KEY (id_profissional) 
        REFERENCES profissionais(id) 
        ON UPDATE CASCADE 
        ON DELETE CASCADE,
    -- Garantir que os horários façam sentido
    CONSTRAINT hora_fim_maior_que_inicio CHECK (hora_fim > hora_inicio),
    -- Evitar duplicatas de dia para o mesmo profissional
    CONSTRAINT unique_dia_profissional UNIQUE (id_profissional, dia_semana)
);

-- Criar tabela de exceções (folgas, feriados, etc)
CREATE TABLE public.excecoes_disponibilidade (
    id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    id_profissional bigint NOT NULL,
    data_inicio TIMESTAMP WITH TIME ZONE NOT NULL,
    data_fim TIMESTAMP WITH TIME ZONE NOT NULL,
    motivo TEXT,
    CONSTRAINT excecoes_disponibilidade_pkey PRIMARY KEY (id),
    CONSTRAINT excecoes_disponibilidade_id_profissional_fkey 
        FOREIGN KEY (id_profissional) 
        REFERENCES profissionais(id) 
        ON UPDATE CASCADE 
        ON DELETE CASCADE,
    -- Garantir que as datas façam sentido
    CONSTRAINT data_fim_maior_que_inicio CHECK (data_fim > data_inicio)
);

-- Criar índices para melhor performance
CREATE INDEX idx_disponibilidade_profissional_id ON disponibilidade_profissional(id_profissional);
CREATE INDEX idx_excecoes_disponibilidade_id ON excecoes_disponibilidade(id_profissional);
CREATE INDEX idx_excecoes_disponibilidade_datas ON excecoes_disponibilidade(data_inicio, data_fim);

-- Adicionar políticas RLS para segurança
ALTER TABLE disponibilidade_profissional ENABLE ROW LEVEL SECURITY;
ALTER TABLE excecoes_disponibilidade ENABLE ROW LEVEL SECURITY;

-- Política para disponibilidade regular
CREATE POLICY "Disponibilidade visível para usuários autenticados" ON disponibilidade_profissional
    FOR SELECT
    TO authenticated
    USING (true);

CREATE POLICY "Apenas administradores podem modificar disponibilidade" ON disponibilidade_profissional
    FOR ALL
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM profissionais p
            WHERE p.id = disponibilidade_profissional.id_profissional
            AND p.nivel = true
            AND p.uid = auth.uid()
        )
    );

-- Política para exceções
CREATE POLICY "Exceções visíveis para usuários autenticados" ON excecoes_disponibilidade
    FOR SELECT
    TO authenticated
    USING (true);

CREATE POLICY "Apenas administradores podem modificar exceções" ON excecoes_disponibilidade
    FOR ALL
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM profissionais p
            WHERE p.id = excecoes_disponibilidade.id_profissional
            AND p.nivel = true
            AND p.uid = auth.uid()
        )
    );

-- Criar função para verificar disponibilidade
CREATE OR REPLACE FUNCTION verificar_disponibilidade_profissional(
    p_id_profissional bigint,
    p_data timestamp with time zone,
    p_duracao interval DEFAULT '1 hour'::interval
) RETURNS boolean
LANGUAGE plpgsql
AS $$
DECLARE
    v_dia_semana dia_semana;
    v_hora time;
    v_disponivel boolean;
BEGIN
    -- Extrair dia da semana e hora
    v_dia_semana := CASE EXTRACT(DOW FROM p_data)
        WHEN 0 THEN 'domingo'::dia_semana
        WHEN 1 THEN 'segunda'::dia_semana
        WHEN 2 THEN 'terca'::dia_semana
        WHEN 3 THEN 'quarta'::dia_semana
        WHEN 4 THEN 'quinta'::dia_semana
        WHEN 5 THEN 'sexta'::dia_semana
        WHEN 6 THEN 'sabado'::dia_semana
    END;
    v_hora := p_data::time;

    -- Verificar disponibilidade regular
    SELECT EXISTS (
        SELECT 1
        FROM disponibilidade_profissional
        WHERE id_profissional = p_id_profissional
        AND dia_semana = v_dia_semana
        AND hora_inicio <= v_hora
        AND hora_fim >= (v_hora + p_duracao)
        AND ativo = true
    ) INTO v_disponivel;

    -- Se não está disponível no horário regular, retorna false
    IF NOT v_disponivel THEN
        RETURN false;
    END IF;

    -- Verificar se não há exceções para o período
    RETURN NOT EXISTS (
        SELECT 1
        FROM excecoes_disponibilidade
        WHERE id_profissional = p_id_profissional
        AND data_inicio <= p_data
        AND data_fim >= (p_data + p_duracao)
    );
END;
$$;
